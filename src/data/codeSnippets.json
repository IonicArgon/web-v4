[
  {
    "language": "cpp",
    "snippet": "//* autonomous selector\n\n#include \"autos/autonomous.h\"\n#include \"display/lv_core/lv_obj.h\"\n#include \"display/lv_core/lv_style.h\"\n#include \"display/lv_hal/lv_hal_disp.h\"\n#include \"display/lv_misc/lv_color.h\"\n#include \"display/lv_objx/lv_btn.h\"\n#include \"display/lv_objx/lv_label.h\"\n#include \"gui/guiGlobals.h\"\n#include \"pros/rtos.hpp\"\n#include <cstdio>\n\nnamespace GUI {\n// objects\nlv_obj_t *liveAutoButton;\nlv_obj_t *skillsAutoButton;\nlv_obj_t *testAutoButton;\nlv_obj_t *autoSelectButton;\nlv_obj_t *liveAutoButtonLabel;\nlv_obj_t *skillsAutoButtonLabel;\nlv_obj_t *testAutoButtonLabel;\nlv_obj_t *autoSelectButtonLabel;\nlv_obj_t *autonomousSelectedLabel;\nlv_obj_t *trollImage;\n\nlv_style_t *autonomousButtonStyle;\nlv_style_t *autonomousConfirmButtonStyle;\n\nstd::string autonomousSelectedText = \"NONE\";\nstd::string autonomousSelectedTextBuffer = {};\nstd::string autoSelectButtonLabelBuffer = {};\n\n// function declarations\nlv_style_t *createButtonStyle(lv_style_t *copy, lv_color_t rel, lv_color_t pr,\n                              lv_color_t textColor, lv_color_t borderColor,\n                              lv_coord_t borderWidth);\nlv_res_t selectAutonomous(lv_obj_t *btn);\nlv_res_t confirmAutonomousSelection(lv_obj_t *btn);\n\n// gui drawing\nvoid drawSelector(void) {\n  autonomousButtonStyle = createButtonStyle(\n      &lv_style_plain, LV_COLOR_MAKE(128, 128, 128),\n      LV_COLOR_MAKE(192, 192, 192), LV_COLOR_MAKE(255, 255, 255),\n      LV_COLOR_MAKE(0, 0, 0), 2);\n  autonomousConfirmButtonStyle = createButtonStyle(\n      &lv_style_plain, LV_COLOR_MAKE(255, 70, 70), LV_COLOR_MAKE(255, 102, 102),\n      LV_COLOR_MAKE(255, 255, 255), LV_COLOR_MAKE(0, 0, 0), 2);\n\n  liveAutoButton = lv_btn_create(lv_scr_act(), NULL);\n  skillsAutoButton = lv_btn_create(lv_scr_act(), NULL);\n  testAutoButton = lv_btn_create(lv_scr_act(), NULL);\n  autoSelectButton = lv_btn_create(lv_scr_act(), NULL);\n\n  lv_obj_set_free_num(liveAutoButton, 0);\n  lv_obj_set_free_num(skillsAutoButton, 1);\n  lv_obj_set_free_num(testAutoButton, 2);\n  lv_obj_set_free_num(autoSelectButton, 3);\n\n  lv_btn_set_action(liveAutoButton, LV_BTN_ACTION_CLICK, selectAutonomous);\n  lv_btn_set_action(skillsAutoButton, LV_BTN_ACTION_CLICK, selectAutonomous);\n  lv_btn_set_action(testAutoButton, LV_BTN_ACTION_CLICK, selectAutonomous);\n  lv_btn_set_action(autoSelectButton, LV_BTN_ACTION_CLICK,\n                    confirmAutonomousSelection);\n\n  lv_btn_set_style(liveAutoButton, LV_BTN_STYLE_REL, &autonomousButtonStyle[0]);\n  lv_btn_set_style(skillsAutoButton, LV_BTN_STYLE_REL,\n                   &autonomousButtonStyle[0]);\n  lv_btn_set_style(testAutoButton, LV_BTN_STYLE_REL, &autonomousButtonStyle[0]);\n  lv_btn_set_style(liveAutoButton, LV_BTN_STYLE_PR, &autonomousButtonStyle[1]);\n  lv_btn_set_style(skillsAutoButton, LV_BTN_STYLE_PR,\n                   &autonomousButtonStyle[1]);\n  lv_btn_set_style(testAutoButton, LV_BTN_STYLE_PR, &autonomousButtonStyle[1]);\n  lv_btn_set_style(autoSelectButton, LV_BTN_STYLE_REL,\n                   &autonomousConfirmButtonStyle[0]);\n  lv_btn_set_style(autoSelectButton, LV_BTN_STYLE_PR,\n                   &autonomousConfirmButtonStyle[1]);\n\n  lv_obj_set_size(liveAutoButton, 160, 50);\n  lv_obj_set_size(skillsAutoButton, 160, 50);\n  lv_obj_set_size(testAutoButton, 160, 50);\n  lv_obj_set_size(autoSelectButton, 480, 50);\n\n  lv_obj_align(liveAutoButton, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 0);\n  lv_obj_align(skillsAutoButton, NULL, LV_ALIGN_IN_TOP_LEFT, 160, 0);\n  lv_obj_align(testAutoButton, NULL, LV_ALIGN_IN_TOP_LEFT, 320, 0);\n  lv_obj_align(autoSelectButton, NULL, LV_ALIGN_IN_TOP_LEFT, 0, 50);\n\n  liveAutoButtonLabel = lv_label_create(liveAutoButton, NULL);\n  skillsAutoButtonLabel = lv_label_create(skillsAutoButton, NULL);\n  testAutoButtonLabel = lv_label_create(testAutoButton, NULL);\n  autoSelectButtonLabel = lv_label_create(autoSelectButton, NULL);\n  lv_label_set_text(liveAutoButtonLabel, \"Live\");\n  lv_label_set_text(skillsAutoButtonLabel, \"Skills\");\n  lv_label_set_text(testAutoButtonLabel, \"Test\");\n  lv_label_set_text(autoSelectButtonLabel, \"Confirm Selection\");\n\n  autonomousSelectedLabel = lv_label_create(lv_scr_act(), NULL);\n  autonomousSelectedTextBuffer =\n      \"Autonomous selected: \" + autonomousSelectedText;\n  lv_label_set_text(autonomousSelectedLabel,\n                    autonomousSelectedTextBuffer.c_str());\n  lv_obj_align(autonomousSelectedLabel, NULL, LV_ALIGN_CENTER, 0, 45);\n}\n\n// function definitions\nlv_style_t *createButtonStyle(lv_style_t *copy, lv_color_t rel, lv_color_t pr,\n                              lv_color_t textColor, lv_color_t borderColor,\n                              lv_coord_t borderWidth) {\n  lv_style_t *buttonStyle = (lv_style_t *)malloc(sizeof(lv_style_t) * 2);\n  for (int i = 0; i < 2; ++i) {\n    lv_style_copy(&buttonStyle[i], copy);\n  }\n\n  buttonStyle[0].body.main_color = rel;\n  buttonStyle[0].body.grad_color = rel;\n  buttonStyle[0].body.border.color = borderColor;\n  buttonStyle[0].body.border.width = borderWidth;\n  buttonStyle[0].text.color = textColor;\n\n  buttonStyle[1].body.main_color = pr;\n  buttonStyle[1].body.grad_color = pr;\n  buttonStyle[1].body.border.color = borderColor;\n  buttonStyle[1].body.border.width = borderWidth;\n  buttonStyle[1].text.color = textColor;\n\n  return buttonStyle;\n}\n\nlv_res_t selectAutonomous(lv_obj_t *btn) {\n  uint8_t id = lv_obj_get_free_num(btn);\n  switch (id) {\n  case 0:\n    Autonomous::autonomousSelection = Autonomous::e_autonomousSelection::E_LIVE;\n    autonomousSelectedText = \"LIVE\";\n    autonomousSelectedTextBuffer =\n        \"Autonomous selected: \" + autonomousSelectedText;\n    lv_label_set_text(autonomousSelectedLabel,\n                      autonomousSelectedTextBuffer.c_str());\n    lv_obj_align(autonomousSelectedLabel, NULL, LV_ALIGN_CENTER, 0, 45);\n    break;\n  case 1:\n    Autonomous::autonomousSelection =\n        Autonomous::e_autonomousSelection::E_SKILLS;\n    autonomousSelectedText = \"SKILLS\";\n    autonomousSelectedTextBuffer =\n        \"Autonomous selected: \" + autonomousSelectedText;\n    lv_label_set_text(autonomousSelectedLabel,\n                      autonomousSelectedTextBuffer.c_str());\n    lv_obj_align(autonomousSelectedLabel, NULL, LV_ALIGN_CENTER, 0, 45);\n    break;\n  case 2:\n    Autonomous::autonomousSelection = Autonomous::e_autonomousSelection::E_TEST;\n    autonomousSelectedText = \"TEST\";\n    autonomousSelectedTextBuffer =\n        \"Autonomous selected: \" + autonomousSelectedText;\n    lv_label_set_text(autonomousSelectedLabel,\n                      autonomousSelectedTextBuffer.c_str());\n    lv_obj_align(autonomousSelectedLabel, NULL, LV_ALIGN_CENTER, 0, 45);\n    break;\n  }\n\n  return LV_RES_OK;\n}\n\nlv_res_t confirmAutonomousSelection(lv_obj_t *btn) {\n  if (Autonomous::autonomousSelection == Autonomous::e_autonomousSelection::E_NONE) {\n    autoSelectButtonLabelBuffer = \"No autonomous selected.\";\n    lv_label_set_text(autoSelectButtonLabel,\n                      autoSelectButtonLabelBuffer.c_str());\n    return LV_RES_OK;\n  }\n\n  if (Autonomous::autonomousSelectionConfirmation == 0) {\n    ++Autonomous::autonomousSelectionConfirmation;\n    autoSelectButtonLabelBuffer = \"Confirm selected? \" + autonomousSelectedText;\n    lv_label_set_text(autoSelectButtonLabel,\n                      autoSelectButtonLabelBuffer.c_str());\n  } else if (Autonomous::autonomousSelectionConfirmation == 1) {\n    Autonomous::autonomousSelectionConfirmation = 2;\n  }\n\n  return LV_RES_OK;\n}\n\n} // namespace GUI"
  },
  {
    "language": "cpp",
    "snippet": "//* bad hardware shit\n//* chassis\n\n//* headers\n#include \"hardware/Chassis.h\"\n#include \"lib/misc/RobotConst.h\"\n#include \"lib/misc/Units.h\"\n#include \"okapi/api/device/motor/abstractMotor.hpp\"\n\nnamespace Hardware {\n\n//? ctor & dtor\nChassis::Chassis(MotorGroup &leftMotors, MotorGroup &rightMotors)\n    : m_leftMotors(leftMotors), m_rightMotors(rightMotors),\n      m_leftEncoder(NULL_ADI_PORT, NULL_ADI_PORT),\n      m_rightEncoder(NULL_ADI_PORT, NULL_ADI_PORT), m_imu(NULL_SMART_PORT),\n      m_advancedTracking(false) {}\n\nChassis::Chassis(MotorGroup &leftMotors, MotorGroup &rightMotors,\n                 pros::ADIEncoder leftEncoder, pros::ADIEncoder rightEncoder,\n                 pros::Imu imu)\n    : m_leftMotors(leftMotors), m_rightMotors(rightMotors),\n      m_leftEncoder(leftEncoder), m_rightEncoder(rightEncoder), m_imu(imu),\n      m_advancedTracking(true) {\n  configureTracking();\n}\n\nChassis::~Chassis() {\n  // do nothing\n}\n\n//? setters\nChassis &Chassis::setBrakeMode(okapi::AbstractMotor::brakeMode mode) {\n  m_leftMotors.setBrakeMode(mode);\n  m_rightMotors.setBrakeMode(mode);\n  return *this;\n}\n\nChassis &Chassis::tarePosition(void) {\n  if (m_advancedTracking) {\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n  } else {\n    m_leftMotors.tarePosition();\n    m_rightMotors.tarePosition();\n  }\n  return *this;\n}\n\n//? getters\nrt_t Chassis::getPosition(char side) const {\n  if (m_advancedTracking) {\n    if (side == 'l') {\n      return m_leftEncoder.get_value();\n    } else if (side == 'r') {\n      return m_rightEncoder.get_value();\n    } else {\n      return 0;\n    }\n  } else {\n    if (side == 'l') {\n      return m_leftMotors.getPosition();\n    } else if (side == 'r') {\n      return m_rightMotors.getPosition();\n    } else {\n      return 0;\n    }\n  }\n}\n\ndeg_t Chassis::getHeading(void) const {\n  if (m_advancedTracking) {\n    return m_imu.get_heading();\n  } else {\n    return 0;\n  }\n}\n\n//? methods\nvoid Chassis::driveJoystick(int joystickLeft, int joystickRight) {\n  rpm_t leftVelocity = (joystickLeft / 127.0) * DRIVE_MAX_VELOCITY;\n  rpm_t rightVelocity = (joystickRight / 127.0) * DRIVE_MAX_VELOCITY;\n\n  driveVelocity(leftVelocity, rightVelocity);\n}\n\nvoid Chassis::driveVelocity(rpm_t leftVelocity, rpm_t rightVelocity) {\n  m_leftMotors.moveVelocity(leftVelocity);\n  m_rightMotors.moveVelocity(rightVelocity);\n}\n\nvoid Chassis::driveVoltage(mV_t leftVoltage, mV_t rightVoltage) {\n  m_leftMotors.moveVoltage(leftVoltage);\n  m_rightMotors.moveVoltage(rightVoltage);\n}\n\n//? private methods\nvoid Chassis::configureTracking(void) {\n    m_imu.reset();\n    m_leftEncoder.reset();\n    m_rightEncoder.reset();\n    while (m_imu.is_calibrating()) {\n        pros::delay(10);\n    }\n}\n\n} // namespace Hardware"
  },
  {
    "language": "cpp",
    "snippet": "//* operator control code\n\n//* headers\n#include \"display/lv_objx/lv_label.h\"\n#include \"gui/guiGlobals.h\"\n#include \"hardware/Arms.h\"\n#include \"hardware/Globals.h\"\n#include \"lib/control/PID.h\"\n#include \"lib/control/filter/AbstractFilter.h\"\n#include \"lib/control/filter/EMAFilter.h\"\n#include \"lib/control/filter/PassthroughFilter.h\"\n#include \"lib/libApi.h\"\n#include \"lib/misc/RobotConst.h\"\n#include \"lib/util/Timer.h\"\n#include \"main.h\"\n#include \"pros/misc.h\"\n#include <algorithm>\n\n//* function declarations\nint deadzone(int value, int comp);\nvoid driving(void);\nvoid armsNaive(void);\nvoid armsPID(void);\nvoid liftPID(void);\nvoid holderPID(void);\nvoid conveyor(void);\n\n//* mutexes\npros::Mutex obj_liftMutex;\npros::Mutex obj_holderMutex;\n\n//* local variables\nHardware::e_armPositions liftPosition{Hardware::e_armPositions::E_STOW};\nHardware::e_armPositions holderPosition{Hardware::e_armPositions::E_STOW};\nconst double voltageRateArms{450.0};\n\n//* opcontrol callback\nvoid opcontrol() {\n  lv_label_set_text(GUI::autonomousSelectedLabel, \"Running opcontrol.\");\n  lv_obj_align(GUI::autonomousSelectedLabel, NULL, LV_ALIGN_IN_TOP_MID, 0, 200);\n\n  obj_arms.tarePosition();\n\n  pros::Task drivingFunction{driving};\n  pros::Task armsFunction{armsPID};\n  pros::Task liftFunction{liftPID};\n  pros::Task holderFunction{holderPID};\n  pros::Task conveyorFunction{conveyor};\n  pros::Task armsFunctionPId{armsPID};\n}\n\n//? the other stuff\n\n//* driving\nvoid driving(void) {\n  const int joystickDeadzone{10};\n\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n    int power{deadzone(\n        obj_controlMaster.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_Y),\n        joystickDeadzone)},\n        turn{deadzone(\n            obj_controlMaster.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X),\n            joystickDeadzone)};\n    obj_chassis.driveJoystick(power + turn, power - turn);\n    pros::delay(10);\n  }\n}\n\n//* arms\nvoid armsNaive(void) {\n  using Hardware::e_armPositions;\n\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n\n    if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_L1))\n      obj_arms.setVelocity('l', 100);\n    else if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_L2))\n      obj_arms.setVelocity('l', -100);\n    else\n      obj_arms.setVelocity('l', 0);\n\n    if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_UP))\n      obj_arms.setVelocity('h', 100);\n    else if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_DOWN))\n      obj_arms.setVelocity('h', -100);\n    else\n      obj_arms.setVelocity('h', 0);\n\n    pros::delay(10);\n  }\n}\n\n//* lift\nvoid armsPID(void) {\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n    if (obj_controlMaster.get_digital_new_press(\n            pros::E_CONTROLLER_DIGITAL_L1)) {\n      obj_liftMutex.take(TIMEOUT_MAX);\n      int foo = static_cast<int>(liftPosition);\n      foo = (foo < 2) ? foo + 1 : 2;\n      liftPosition = static_cast<Hardware::e_armPositions>(foo);\n      obj_liftMutex.give();\n    } else if (obj_controlMaster.get_digital_new_press(\n                   pros::E_CONTROLLER_DIGITAL_L2)) {\n      obj_liftMutex.take(TIMEOUT_MAX);\n      int foo = static_cast<int>(liftPosition);\n      foo = (foo > 0) ? foo - 1 : 0;\n      liftPosition = static_cast<Hardware::e_armPositions>(foo);\n      obj_liftMutex.give();\n    }\n\n    if (obj_controlMaster.get_digital_new_press(\n            pros::E_CONTROLLER_DIGITAL_DOWN)) {\n      obj_holderMutex.take(TIMEOUT_MAX);\n      int foo = static_cast<int>(holderPosition);\n      foo = (foo < 1) ? foo + 1 : 1;\n      holderPosition = static_cast<Hardware::e_armPositions>(foo);\n      obj_holderMutex.give();\n    } else if (obj_controlMaster.get_digital_new_press(\n                   pros::E_CONTROLLER_DIGITAL_UP)) {\n      obj_holderMutex.take(TIMEOUT_MAX);\n      int foo = static_cast<int>(holderPosition);\n      foo = (foo > 0) ? foo - 1 : 0;\n      holderPosition = static_cast<Hardware::e_armPositions>(foo);\n      obj_holderMutex.give();\n    }\n\n    pros::delay(10);\n  }\n}\n\n//* lift PID\nvoid liftPID(void) {\n  double oldVoltage{0.0};\n  Lib1104A::Control::PIDGains liftGains{3.0, 0.01, 0.5};\n  Lib1104A::Control::AbstractFilter *liftFilter =\n      new Lib1104A::Control::PassthroughFilter();\n  Lib1104A::Control::PID liftPID{liftGains, liftFilter};\n  const int deadzoneZero{20};\n\n  liftPID.reset();\n\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n    obj_liftMutex.take(TIMEOUT_MAX);\n    int target = []() {\n      if (liftPosition == Hardware::e_armPositions::E_STOW)\n        return LIFT_RESET_POSITION;\n      else if (liftPosition == Hardware::e_armPositions::E_LOW)\n        return LIFT_LOW_POSITION;\n      else if (liftPosition == Hardware::e_armPositions::E_HIGH)\n        return LIFT_HIGH_POSITION;\n\n      return LIFT_RESET_POSITION;\n    }();\n    obj_liftMutex.give();\n\n    liftPID.setTarget(target);\n\n    rt_t travel = obj_arms.getPosition('l');\n    double voltage = 12'000 * liftPID.calculate(travel, 10);\n\n    voltage = std::clamp(voltage, oldVoltage - voltageRateArms,\n                         oldVoltage + voltageRateArms);\n\n    //* if our target is zero then we must handle this differently\n    if (target == LIFT_RESET_POSITION && deadzone(travel, deadzoneZero)) {\n      voltage = -6'000;\n    } else if (target == LIFT_RESET_POSITION &&\n               !deadzone(travel, deadzoneZero)) {\n      voltage = 0;\n    }\n\n    obj_arms.setVoltage('l', voltage);\n\n    oldVoltage = voltage;\n\n    pros::delay(10);\n  }\n}\n\n//* holder PID\nvoid holderPID(void) {\n  double oldVoltage{0.0};\n  Lib1104A::Control::PIDGains holderGains{1.0, 0.005, 0.1};\n  Lib1104A::Control::AbstractFilter *holderFilter =\n      new Lib1104A::Control::PassthroughFilter();\n  Lib1104A::Control::PID holderPID{holderGains, holderFilter};\n\n  holderPID.reset();\n\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n    obj_holderMutex.take(TIMEOUT_MAX);\n    int target = []() {\n      if (holderPosition == Hardware::e_armPositions::E_STOW)\n        return HOLDER_RESET_POSITION;\n      else if (holderPosition == Hardware::e_armPositions::E_LOW)\n        return HOLDER_HIGH_POSITION;\n\n      return HOLDER_RESET_POSITION;\n    }();\n    obj_holderMutex.give();\n\n    holderPID.setTarget(target);\n\n    rt_t travel = obj_arms.getPosition('h');\n    double voltage = 12'000 * holderPID.calculate(travel, 10);\n\n    voltage = std::clamp(voltage, oldVoltage - voltageRateArms,\n                         oldVoltage + voltageRateArms);\n\n    obj_arms.setVoltage('h', voltage);\n\n    oldVoltage = voltage;\n\n    pros::delay(10);\n  }\n}\n\n//* conveyor\nvoid conveyor(void) {\n  while (!(pros::competition::is_autonomous() ||\n           pros::competition::is_disabled())) {\n    if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_R1)) {\n      obj_conveyor.setVelocity(CONVEYOR_MAX_VELOCITY);\n    } else if (obj_controlMaster.get_digital(pros::E_CONTROLLER_DIGITAL_R2)) {\n      obj_conveyor.setVelocity(-CONVEYOR_MAX_VELOCITY);\n    } else {\n      obj_conveyor.setVelocity(0);\n    }\n    pros::delay(10);\n  }\n}\n\n//* deadzone func\nint deadzone(int value, int comp) { return std::abs(value) < comp ? 0 : value; }"
  },
  {
    "language": "py",
    "snippet": "import toml\nimport logging\nimport random\nimport discord\nimport typing\nfrom discord.ext import commands, tasks\nfrom Identity import Identity, IdentityProfile\nfrom collections import deque\n\n\nclass BaseCog(commands.Cog):\n    # static variables\n    identity_config = toml.load(\"Identity_config.toml\")\n    config = toml.load(\"config.toml\")\n    identities = []\n    identity_history = None\n    member_storage = []\n    channels = []\n    GAME = \"limbus\"\n\n    def __init__(self, bot: commands.Bot) -> None:\n        self.bot = bot\n        if len(BaseCog.identities) == 0:\n            BaseCog.identities = self._load_identities()\n            BaseCog.identity_history = deque(maxlen=(len(self.identities) // 2))\n\n        if len(self.channels) == 0:\n            BaseCog.channels = self._load_channels()\n\n    # events\n\n    @tasks.loop(hours=1)\n    async def reload_config(self) -> None:\n        await self.bot.wait_until_ready()\n        logging.info(\"Reloading config\")\n\n        BaseCog.identity_config = toml.load(\"Identity_config.toml\")\n        BaseCog.configs = toml.load(\"config.toml\")\n        BaseCog.identities = self._load_identities()\n        BaseCog.identity_history = deque(maxlen=(len(self.identities) // 2))\n        BaseCog.channels = self._load_channels()\n\n    # helper functions\n\n    def _load_identities(self) -> list[Identity]:\n        profiles = BaseCog.identity_config[\"identity\"]\n        profiles = [\n            IdentityProfile(\n                avatar=profile[\"avatar\"],\n                user=profile[\"user\"],\n                greetings=profile[\"greetings\"],\n                colour=int(profile[\"colour\"], 16),\n            )\n            for profile in profiles\n        ]\n        return [Identity(profile) for profile in profiles]\n\n    def _create_base_embed(\n        self, title: str, description: str, identity: Identity\n    ) -> discord.Embed:\n        embed = discord.Embed(\n            title=title,\n            description=description,\n            colour=identity.colour,\n        )\n        embed.set_footer(\n            text=\"Bot created by .extro\",\n            icon_url=\"https://cdn.discordapp.com/avatars/244948020569964545/553692a2ef6f042857754748630170f5?size=1024\",\n        )\n\n        return embed\n\n    async def _establish_webhook(self, channel: discord.TextChannel) -> discord.Webhook:\n        webhooks = await channel.webhooks()\n        webhook = discord.utils.get(webhooks, name=\"Don Quixote Webhook\")\n        if webhook is None:\n            avatar = None\n            with open(\"../public/icon.png\", \"rb\") as f:\n                avatar = bytearray(f.read())\n\n            webhook = await channel.create_webhook(\n                name=\"Don Quixote Webhook\", avatar=avatar\n            )\n        return webhook\n\n    async def _send_webhook(\n        self,\n        channel: discord.TextChannel,\n        identity: Identity,\n        embed: discord.Embed,\n        view: discord.ui.View = None,\n        persistent: bool = True,\n    ) -> None:\n        webhook = await self._establish_webhook(channel)\n        if view is not None:\n            await webhook.send(\n                username=identity.user,\n                avatar_url=identity.avatar,\n                embed=embed,\n                view=view,\n            )\n        else:\n            await webhook.send(\n                username=identity.user,\n                avatar_url=identity.avatar,\n                embed=embed,\n            )\n\n        if not persistent:\n            await webhook.delete()\n\n    def _random_identity(self) -> Identity:\n        identity = random.choice(BaseCog.identities)\n        while identity in BaseCog.identity_history:\n            identity = random.choice(BaseCog.identities)\n        BaseCog.identity_history.append(identity)\n        return identity\n\n    def _load_channels(\n        self,\n    ) -> list[tuple[discord.Guild, discord.TextChannel, discord.VoiceChannel]]:\n        channels = []\n\n        for guild in self.bot.guilds:\n            text_channels = guild.text_channels\n            voice_channels = guild.voice_channels\n\n            channel = None\n            voice = None\n\n            for guild_config in BaseCog.config[\"guilds\"]:\n                if guild_config[\"id\"] == guild.id:\n                    channel = discord.utils.get(text_channels, id=guild_config[\"text\"])\n                    voice = discord.utils.get(voice_channels, id=guild_config[\"voice\"])\n                    break\n\n            if channel is None or voice is None:\n                channel, voice = text_channels[0], voice_channels[0]\n\n            channels.append((guild, channel, voice))\n\n        logging.info(f\"Channels: {channels}\")\n        return channels\n\n    async def _member_gen(\n        self, guild: discord.Guild\n    ) -> typing.AsyncGenerator[discord.Member, None]:\n        async for member in guild.fetch_members(limit=None):\n            yield member\n\n    def check_member_activity(\n        self, member: discord.Member, guild: discord.Guild\n    ) -> bool:\n        if len(member.activities) == 0:\n            return False\n\n        for activity in member.activities:\n            if (\n                self.GAME in activity.name.lower()\n                and activity.type == discord.ActivityType.playing\n            ):\n                if (member, guild) not in BaseCog.member_storage:\n                    BaseCog.member_storage.append((member, guild))\n                    return True\n                else:\n                    return False\n\n        if member in self.member_storage:\n            BaseCog.member_storage.remove((member, guild))\n\n        return False\n\n\ndef setup(bot: commands.Bot) -> None:\n    bot.add_cog(BaseCog(bot))"
  },
  {
    "language": "tsx",
    "snippet": "'use client';\n\nimport React from 'react';\nimport {\n  Fieldset,\n  Legend,\n  Field,\n  Label,\n  Description,\n  Input,\n  Select,\n  Textarea,\n} from '@headlessui/react';\n\ntype FieldType = 'text' | 'select' | 'textarea';\n\ntype DynamicField = {\n  label: string;\n  description?: string;\n  type: FieldType;\n  path: string;\n  options?: string[];\n  value?: any;\n};\n\ntype JobDataCardProps = {\n  title: string;\n  fields: DynamicField[];\n  onFieldChange: (field: DynamicField, value: any) => void;\n  formErrors?: any[];\n};\n\nconst JobDataCard: React.FC<JobDataCardProps> = ({\n  title,\n  fields,\n  onFieldChange,\n  formErrors = [],\n}) => {\n  return (\n    <Fieldset className=\"p-4 border rounded-md\">\n      <Legend className=\"text-lg font-semibold\">{title}</Legend>\n\n      <div className=\"grid grid-cols-2 gap-4\">\n        {fields.map((field) => {\n          const fieldErrors = formErrors.filter(\n            (error) => error.path.join('.') === field.path,\n          );\n\n          return (\n            <Field key={field.label} as=\"div\" className=\"mb-4\">\n              <Label className=\"block text-sm font-medium text-gray-700\">\n                {field.label}\n              </Label>\n              {field.description && (\n                <Description className=\"text-sm text-gray-500\">\n                  {field.description}\n                </Description>\n              )}\n\n              {field.type === 'text' && (\n                <div>\n                  <Input\n                    type=\"text\"\n                    className={`m/t-1 block w-full rounded-md border-2 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 ${fieldErrors.length > 0 ? 'border-red-500' : 'border-gray-300'}`}\n                    value={field.value}\n                    onChange={(e) => onFieldChange(field, e.target.value)}\n                  />\n                  {fieldErrors.map((error, index) => (\n                    <p key={index} className=\"text-red-500 text-sm\">\n                      {error.message}\n                    </p>\n                  ))}\n                </div>\n              )}\n\n              {field.type === 'select' && (\n                <div>\n                  <Select\n                    className={`mt-1 block w-full shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 ${fieldErrors.length > 0 ? 'border-red-500' : 'border-gray-300'}`}\n                    value={field.value}\n                    onChange={(e) => onFieldChange(field, e.target.value)}\n                  >\n                    {field.options?.map((option) => (\n                      <option key={option} value={option}>\n                        {option}\n                      </option>\n                    ))}\n                  </Select>\n                  {fieldErrors.map((error, index) => (\n                    <p key={index} className=\"text-red-500 text-sm\">\n                      {error.message}\n                    </p>\n                  ))}\n                </div>\n              )}\n\n              {field.type === 'textarea' && (\n                <div>\n                  <p className=\"mr-2 mt-1 text-xs\">\n                    {`${field.value.length} of ${field.options?.[0]} characters used`}\n                  </p>\n                  <Textarea\n                    className={`m/t-1 block w-full rounded-md border-2 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 ${fieldErrors.length > 0 ? 'border-red-500' : 'border-gray-300'}`}\n                    value={field.value}\n                    onChange={(e) => {\n                      const maxLength = parseInt(field.options?.[0] || '200');\n                      const newValue = e.target.value;\n                      if (newValue.length <= maxLength) {\n                        onFieldChange(field, newValue);\n                      } else {\n                        onFieldChange(field, newValue.slice(0, maxLength));\n                      }\n                    }}\n                  />\n                  {fieldErrors.map((error, index) => (\n                    <p key={index} className=\"text-red-500 text-sm\">\n                      {error.message}\n                    </p>\n                  ))}\n                </div>\n              )}\n            </Field>\n          );\n        })}\n      </div>\n    </Fieldset>\n  );\n};\n\nexport default JobDataCard;\nexport type { DynamicField };"
  },
  {
    "language": "rs",
    "snippet": "// file stuff\nuse serde_json;\nuse std::io::prelude::*;\nuse std::path::Path;\nuse std::{fmt::Debug, fs::File};\n\n// password stuff\nuse argon2::{\n    password_hash::{PasswordHasher, SaltString},\n    Argon2,\n};\nuse rand::Rng;\nuse requestty::Question;\n\n// my stuff\nuse crate::errors::AppError;\n\n// ------------------ //\n\npub trait Initialize {\n    fn new(path: String) -> Self;\n    fn start_up(&mut self) -> Result<bool, AppError>;\n    fn create_settings(&self) -> Result<(), AppError>;\n    fn load_settings(&mut self);\n    fn get_password_hash(&self) -> String;\n    fn get_key_salt(&self) -> String;\n}\n\npub struct SettingsInitializer {\n    path: String,\n    password_hash: String,\n    hash_salt: String,\n    derived_key_salt: String,\n}\n\nimpl Initialize for SettingsInitializer {\n    fn new(path: String) -> Self {\n        SettingsInitializer {\n            path,\n            password_hash: String::from(\"\"),\n            hash_salt: String::from(\"\"),\n            derived_key_salt: String::from(\"\"),\n        }\n    }\n\n    fn start_up(&mut self) -> Result<bool, AppError> {\n        // check if the file exists\n        let path = Path::new(&self.path);\n        let mut made_new_file = false;\n\n        if !path.exists() {\n            println!(\"Settings file does not exist. Creating new settings file...\");\n            loop {\n                match self.create_settings() {\n                    Ok(_) => break,\n                    Err(e) => println!(\"{}\", e),\n                }\n            }\n            made_new_file = true;\n        } else {\n            println!(\"Settings file exists. Loading settings...\");\n        }\n\n        self.load_settings();\n\n        Ok(made_new_file)\n    }\n\n    fn create_settings(&self) -> Result<(), AppError> {\n        // create the new json file\n        let mut file = match File::create(&self.path) {\n            Err(why) => panic!(\"Couldn't create settings file: {}\", why),\n            Ok(file) => file,\n        };\n\n        // set up argon2\n        let argon2 = Argon2::default();\n\n        // generate the salt\n        let rng = rand::thread_rng();\n        let salt_string = rng.clone()\n            .sample_iter(rand::distributions::Alphanumeric)\n            .take(32)\n            .map(char::from)\n            .collect::<String>();\n        let salt = SaltString::from_b64(salt_string.as_str()).unwrap();\n\n        // generate the salt used to derive the key\n        let derived_key_salt_string = rng\n            .sample_iter(rand::distributions::Alphanumeric)\n            .take(32)\n            .map(char::from)\n            .collect::<String>();\n\n        // get the password\n        let q_pass = Question::password(\"password\")\n            .message(\"Enter a new password: \")\n            .mask('*')\n            .build();\n\n        let q_pass_confirm = Question::password(\"password_confirm\")\n            .message(\"Confirm your password: \")\n            .mask('*')\n            .build();\n\n        let answers = requestty::prompt(vec![q_pass, q_pass_confirm]).unwrap();\n\n        let password = answers.get(\"password\").unwrap().as_string().unwrap() as &str;\n\n        let password_confirm = answers\n            .get(\"password_confirm\")\n            .unwrap()\n            .as_string()\n            .unwrap() as &str;\n\n        // check if the passwords match\n        if password != password_confirm {\n            return Err(AppError::new(\"Passwords do not match.\"));\n        } else {\n            // hash the password\n            let password_hash = argon2.hash_password(password.as_bytes(), &salt).unwrap();\n\n            // serialize the password hash and salt to json\n            let json = serde_json::json!({\n                \"password_hash\": password_hash.to_string(),\n                \"hash_salt\": salt_string,\n                \"derived_key_salt\": derived_key_salt_string,\n            });\n\n            // write the json to the file\n            match file.write_all(json.to_string().as_bytes()) {\n                Err(why) => panic!(\"Couldn't write to settings file: {}\", why),\n                Ok(_) => println!(\"Successfully wrote to settings file.\"),\n            }\n        }\n\n        Ok(())\n    }\n\n    fn load_settings(&mut self) {\n        // open the file\n        let mut file = match File::open(&self.path) {\n            Err(why) => panic!(\"Couldn't open settings file: {}\", why),\n            Ok(file) => file,\n        };\n\n        // read the file\n        let mut contents = String::new();\n        match file.read_to_string(&mut contents) {\n            Err(why) => panic!(\"Couldn't read settings file: {}\", why),\n            Ok(_) => println!(\"Successfully read settings file.\"),\n        }\n\n        // parse the json\n        let v: serde_json::Value = serde_json::from_str(&contents).unwrap();\n\n        // get the password hash and salt\n        self.password_hash = v[\"password_hash\"].as_str().unwrap_or(\"\").to_string();\n        self.hash_salt = v[\"hash_salt\"].as_str().unwrap_or(\"\").to_string();\n        self.derived_key_salt = v[\"derived_key_salt\"].as_str().unwrap_or(\"\").to_string();\n    }\n\n    fn get_password_hash(&self) -> String {\n        self.password_hash.clone()\n    }\n\n    fn get_key_salt(&self) -> String {\n        self.derived_key_salt.clone()\n    }\n}\n\nimpl Debug for SettingsInitializer {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"SettingsInitializer\")\n            .field(\"path\", &self.path)\n            .field(\"password_hash\", &self.password_hash)\n            .field(\"hash_salt\", &self.hash_salt)\n            .finish()\n    }\n}"
  }
]
